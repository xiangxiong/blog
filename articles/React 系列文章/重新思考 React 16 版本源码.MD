更新机制:
1、React 15 中,每次更新时, 都是从根组件或setState 后组件开始, 更新整个子树.

2、React 16 早期将原来的diff 过程拆分成两个阶段, 第一个阶段叫 reconcile, 也就是原来diff 虚拟dom 的过程。第二个阶段叫commit,commit 就是对应早期版本的patch过程.，在并发模式下，可能多次reconcile 才执行一次，commit.

第一阶段:将虚拟DOM转换成Fiber,Fiber 转换成组件实例或真实DOM（不插入DOM树,插入DOM树会reflow）,还会执行一些轻量的钩子(ComponentWillMount) 等.Fiber转换后两者明显会耗时.

第二阶段:commit 是将水面下的效果浮现出来,比如将节点插入到Dom 树, 修复节点的属性样式文本内容, 执行如componentDidXXX 这样的重量钩子,执行ref 操作.

如何让代码断开重连:
1、JSX 成为组件化的标准化语言,但标签化是天然嵌套的结构, 意味着它会最终编译成递归执行的代码,因此React团队称React16之前的调度器为栈调度器，栈没有什么不好，栈显浅易懂，代码量少，但它的坏处不能随意break掉，continue掉。根据我们上面的实验，break后我们还要重新执行，我们需要一种链表的结构.

2、链表是对异步友好的。链表在循环时不用每次都进入递归函数，重新生成什么执行上下文，变量对象，激活对象，性能当然比递归好.

如何决定每次更新的数量?
如何调度时间才能保证流畅?


时间分片怎么做?
测 试:
现在这两个阶段之前新添加了一个阶段叫Scheduler 调度.
因为一个页面可能有多个ReactDOM.render，虚拟DOM树中也通常存在多个拥有自更新能力的组件.并发模式下，setState 不会立即更新视图.

问 题:
1、转换的过程要不要调用生命周期函数,到底在啥时候调用?
2、转换之后干什么?深度优先遍历？为什么要遍历?
3、是怎么执行中断的?
4、优先级是怎么确定的?

思 考:
过期时间是怎么计算的?
在并发模式下，组件setState不会立即更新视图，于是在一个时间段中，就有多个待更新的组件?

```
fiber{
  	stateNode: {},
    child: {},
    return: {},
    sibling: {}
}
fiber 对象.
```

参考文献:
```
https://juejin.im/post/5ab7b3a2f265da2378403e57.
```

是先调度在更新, fiber 结构帮我们把整个树的以你应用更新流程，拆成每个Fiber 对象为单元的更新流程.

调度图说的是不对的.
