### Should we useReducer hook instead of Redux?

React 16.7中引入的React钩子是一个很大的变化。现在，我们有能力用状态和生命周期方法编写功能组件。不反对使用类组件，但不再使用编写React的方法
组件。

做很多事情都有钩子:

- 组件内部状态管理的useState

- 对生命周期方法使用效果

- useRef用于添加引用

- 用于全局状态管理和其他几个钩子的useReducer。

在我看来useReducer是非常有用的。我们使用熟悉的钩子语法来使用它。有趣的是，它返回了 reducer状态和一个dispatch函数。 reducer状态表示调用 reducer函数后，React所具有的当前状态。dispatch函数允许我们向reducer发送操作对象。

通过使用组件外部的还原剂表示状态，我们首次在React中内置了全局状态管理。那么，像Redux这样的包真的有必要吗?

是的,没有。我将解释这个答案。

useReducer函数与特定的reducer紧密耦合。我们只将action对象dispatch给该reducer。而在Redux中，dispatch函数将action对象发送到存储。在dispatch时，组件不需要知道处理动作的 reducer。

另一个区别是Redux有中间件。Redux thunk和Redux日志记录器是非常有用的中间件。通过这些中间件，我们在使用Redux时增强了功能。

然而，useReducer有一个明显的优势。它不像react-redux那样生成任何包装器组件。向特定的reducer发送一个动作会使应用程序的性能有所提高.

结论: 局部是可以，从大的项目的角度来考虑是不靠谱的.

### Do React Hooks Replace Redux?

自从引入了React hooks API以来，关于React hooks是否会取代Redux的问题就出现了很多。

在我看来，hook和Redux之间几乎没有重叠。hook并没有给我们带来神奇的新状态能力。相反，它为我们已经可以使用React做的事情增强了API。但是，hook API使本机React state API更加可用，而且由于它比它所替换的类模型更容易，所以我在适当的时候比以前更多地使用组件状态。

要理解我的意思，我们首先需要更好地理解为什么要考虑Redux。

回来的是什么?

Redux是一个可预测的状态管理库和体系结构，很容易与React集成。

Redux的主要卖点是:

确定性状态解析(当与纯组件结合时，启用确定性视图呈现)。

事务状态。

将状态管理与I/O和副作用隔离开来。

应用状态的单一真实源。

轻松地在不同组件之间共享状态。

事务遥测(自动记录操作对象)。

时间旅行调试。

换句话说，Redux提供了代码组织和调试的超能力。它使构建更易于维护的代码变得更容易，并且在出现问题时更容易跟踪根本原因。

什么是反应挂钩?

React钩子允许您使用状态和React生命周期特性，而无需使用类和React组件生命周期方法。它们是在16。8反应中引入的。

React hook的主要卖点是:

在不使用类的情况下使用状态和hook到组件生命周期中。

将相关逻辑放在组件中的一个位置，而不是将其分割到不同的生命周期方法中。

共享独立于组件实现的可重用行为(如呈现道具模式)

请注意，这些奇妙的好处实际上并不与Redux的好处重叠。您可以并且应该使用React钩子来获得确定性状态更新，但这一直是React的一个特性，而Redux的确定性状态模型很好地融入了其中。这就是React提供确定性视图呈现的方式，并且确实是创建React的驱动动机之一。

使用像React -redux钩子API和React的useReducer钩子这样的工具，没有必要选择其中一个。同时使用。混合和匹配。

钩子代替了什么?

自从hook API被引入以来，我已经停止使用:

类组件。

渲染道具模式。

什么钩子不能代替?

我仍然经常使用:

基于上面列出的所有原因Redux。

要在所有或大部分应用程序视图共享的横切关注点中组合的高阶组件，例如Redux提供程序、公共布局提供程序、配置提供程序、身份验证/授权、i18n等等。

在容器和显示组件之间进行分离，以获得更好的模块化、可测试性，以及更容易地在效果和纯逻辑之间进行分离。


何时使用挂钩

你并不总是需要每个应用程序或每个组件的Redux。如果您的应用程序由一个视图组成，不保存或加载状态，并且没有异步I/O，我想不出一个好的理由来增加Redux的复杂性。

同样，如果你的组件:

不使用网络。

不保存或加载状态。

不与其他非子组件共享状态。

确实需要一些临时的本地组件状态。

对于React的内置组件状态模型，您可能有一个很好的用例。在这些情况下，React钩子会很好地为您服务。例如，下面的表单使用React中的本地组件状态useState钩子。


此代码使用useState跟踪姓名和电子邮件的临时表单输入状态:


你可能会注意到还有一个removeHolder动作创建器从Redux进入道具。混合搭配很好。

对于这样的事情，使用局部组件状态总是好的，但是在使用React hook之前，我可能会忍不住将它填充到Redux中，并从支持中提取状态。

使用组件状态将意味着使用类组件，使用类实例属性语法(或构造函数)设置初始状态，等等——仅仅为了避免重复而增加了太多的复杂性。有一些即插即用的工具可以用Redux管理表单状态，这对我很有帮助，所以我不必担心短暂的表单状态会影响到我的业务逻辑。

因为我已经在所有重要的应用程序中使用了Redux，所以选择很简单:Redux(几乎)所有的东西!

现在的选择仍然很简单:

组件状态对应组件状态，Redux对应应用程序状态。

何时使用Redux

另一个常见的问题是“你应该把所有东西都放在Redux中吗?”如果你不这么做，它不会中断时间旅行调试吗?”

不，因为应用程序中有很多状态都是短暂的，而且粒度太细，无法为日志遥测或时间旅行调试等提供非常有用的信息。除非您正在构建一个实时协作编辑器，否则您可能不需要将每个用户的击键或鼠标移动都置于Redux状态。当您将一些东西添加到Redux状态时，您就添加了一个抽象层和随之而来的复杂性。

换句话说，您应该可以随意使用Redux，但是当您这样做时，您应该有一个理由。

如果你的组件:

像使用网络或设备api一样使用I/O。

保存或加载状态。

与非子组件共享其状态。

处理与应用程序的其他部分共享的任何业务逻辑或数据处理。

下面是来自TDDDay应用程序的另一个例子:

这个组件不处理任何DOM。它是一个表示组件。它使用React-Redux钩子API连接到Redux。

它使用Redux是因为我们需要这个表单在UI的其他部分关心的数据，当我们完成购买流时，我们需要将数据保存到数据库中。

它所关心的状态是在组件之间共享的，而不是本地化到单个组件，它是持久的而不是临时的，并且它可能跨越多个页面视图或会话。这些都是本地组件状态无法帮助解决的问题，除非您在React API的基础上构建自己的状态容器库——这比仅仅使用Redux要复杂得多.

在未来，React的pending API可能会帮助保存和加载状态。我们将需要等待悬念API着陆，看看它是否可以取代我的保存/加载模式在Redux。Redux允许我们干净地将副作用与组件逻辑的其余部分分开，而不需要模拟I/O服务。(效果的隔离是我更喜欢《魔兽争霸》而不是《雷神之锤》的原因)。为了与这个Redux用例竞争，React的API需要提供效果隔离。

回来的是建筑

Redux比状态管理库要多得多(而且通常要少得多)。它本质上也是Flux体系结构的一个子集，Flux体系结构对如何进行状态更改更有自己的见解。我有另一篇博客文章，其中更详细地介绍了Redux架构。

当需要复杂组件状态但不需要Redux库时，我经常使用Redux风格的约简器。我还使用Redux风格的操作(甚至像Autodux和Redux- saga这样的Redux工具)来分派节点应用程序中的操作，而不需要导入Redux库。

与库相比，Redux更多的是架构和未强制的约定。事实上，Redux的基本实现可以在几十行代码中复制。

如果您想开始在hook API中使用更多的本地组件状态，而不是重新编译所有东西，这将是一个非常好的消息。

React提供了一个useReducer钩子，它将与您的redu风格的还原器进行接口。这对于非平凡状态逻辑、依赖状态等等非常有用。如果您有一个用例，您认为您可以包含单个组件的临时状态，那么您可以使用Redux体系结构，但是使用useReducer钩子而不是使用Redux来管理状态。

如果以后需要坚持或共享状态，那么已经完成了90%。剩下的就是连接组件并将减速器添加到Redux存储中。

更多的问答

“如果一切都不在Redux中，决定论会被打破吗?”

不。事实上，Redux也没有强制执行决定论。公约。如果您希望您的Redux状态是确定的，请使用纯函数。如果希望临时组件状态是确定的，请使用纯函数。

“难道你不需要回报作为唯一的真理来源吗?”

真理的单一来源原则并不是说你需要你所有的状态都来自一个单一的来源。相反，它意味着对于每个状态，都应该有一个单一的真理来源。你可以有许多不同的状态片段，每个片段都有自己的真理来源。

这意味着你可以选择什么进入Redux，什么进入组件状态。您还可以从其他源获取状态，比如用于当前位置href的浏览器api。

Redux是维护应用程序状态的单一真实源的好方法，但是如果您的组件状态本地化为单个组件，并且只在一个地方使用，那么根据定义，它已经拥有该状态的单一真实源:React component state。

如果你确实把一些东西放到了Redux状态，你应该总是从Redux状态读取它。对于Redux中的所有状态，Redux应该是该状态的唯一真理来源。

“我应该使用response -redux connect，还是hook API?”


那得看情况。connect创建了一个可重用的高阶组件，而hook API是为与单个组件集成而优化的。您是否需要将相同的商店道具连接到其他组件?与连接。否则，我更喜欢hook API的读取方式。例如，假设您有一个处理用户操作权限授权的组件:

现在，如果你有一堆管理视图，都需要管理权限，你可以创建一个高阶的组件，在这个权限要求中，所有这些都在你的所有其他横切关注点:

高阶组件API方便这个用例,它实际上比挂钩的API更简洁(它需要更少的代码),但为了读connect API,你必须记住,它将mapStateToProps作为第一个参数,和mapDispatchToProps作为第二个参数,你应该意识到它可以把函数或对象文字,你应该知道这些行为的差异。您还需要记住，它是咖喱，但不是自动咖喱。

换句话说，我发现connect API可以用简洁的代码完成这项工作，但它不是特别易读或符合人体工程学。如果我不需要为其他组件重用连接，那么我更喜欢具有无限可读性的hook API，尽管它需要更多的输入。

“如果单例对象是反模式，而Redux是单例对象，那么Redux不是反模式吗?”

不。单例是一种代码气味，它可以指示共享的可变状态，这是真正的反模式。Redux通过封装防止共享可变状态(您不应该在reduce器之外直接修改应用程序状态，相反，Redux处理状态更新)和消息传递(只有已分派的操作对象才能触发状态更新)。

下一个步骤
在EricElliottJS.com上了解更多关于React和Redux的信息。本文通过大量示例和视频演练深入讨论了代码示例中使用的函数组合和部分应用程序等功能模式。

了解如何对组件进行单元测试，谈到测试，请访问TDDDay.com了解测试驱动开发(test Driven Development, TDD)。

Eric Elliott是《编写软件》和《编写JavaScript应用程序》两本书的作者。他是EricElliottJS.com和DevAnywhere的联合创始人。io教授开发人员基本的软件开发技能。他为加密项目建立和建议开发团队，并为Adobe Systems、Zumba Fitness、华尔街日报、ESPN、BBC以及包括Usher、Frank Ocean、Metallica在内的顶级唱片艺术家提供软件经验。

他和世界上最美丽的女人过着一种遥远的生活。

* 
* https://medium.com/javascript-scene/do-react-hooks-replace-redux-210bab340672

* 思考题:
    * 状态管理的本质是什么？
    * 理解flux 状态管理.
    * 这篇文章看5遍.











* 参考文献:

* https://tddday.com/?source=post_page---------------------------

React hook会取代Redux吗?
https://medium.com/javascript-scene/do-react-hooks-replace-redux-210bab340672

https://hashnode.com/post/should-we-usereducer-hook-instead-of-redux-cjomzn08g01y6hgs1rhtoi03k

https://www.robinwieruch.de/redux-vs-usereducer/

https://vijayt.com/post/good-bye-redux-global-state-using-react-hooks-and-usereducer-function/




