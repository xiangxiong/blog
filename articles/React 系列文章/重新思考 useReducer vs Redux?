需求:如果您还没有学习过JavaScript中的reduce或React中的useReducer，请参阅以下教程。在讨论Redux vs useReducer之前，最好先了解一些基础知识。另外，如果您想了解更多关于Redux的知识，请查看这个扩展的Redux教程。

全局状态容器和组件位于同一位置的状态

管理状态的位置是Redux和useReducer之间的关键区别。当Redux创建一个全局状态容器时(它挂在整个应用程序的上方)，useReducer在组件中创建一个独立的、位于同一位置的状态容器。在继续扩展useReducer的组件位于同一位置的状态管理哲学之前，让我们先来了解一下这个事实。


将useContext与useReducer结合使用可以在另一个级别上实现组件共存状态管理。突然之间，useReducer创建的状态容器及其分派函数可以从任何顶级组件传递到任何组件。它也可以是使状态“全局”的最顶层组件。也可以只通过使用React道具将内容传递下去，但是React的上下文API使您的状态和分派函数在任何地方都可用，而无需显式地将所有内容传递到组件树中。


然而，即使我们能够将所有useReducer状态提升到我们最顶层的组件—几乎使Redux过时，因为它可以被看作全局状态容器—它仍然不是一个全局状态容器。Redux缺少两个组成部分来使其成为一个整体和全球性的。


第一:首先，还没有将所有reducer组合到一个最终reducer的本机特性。Redux提供了这个功能，但是在plain React中，我们必须自己实现它。只有当我们能够将所有状态容器组合成所有useReducer挂钩时，我们才可以说是一个状态容器。

全局:其次，每个useReducer都有自己的分派功能。还没有将所有分派函数组合到一个分派函数的本机特性。Redux提供一个分派函数，该函数使用任何专用于任何减速器函数的操作。相反，useReducer的分派函数只处理要使用的减速函数指定的操作。

虽然useReducer及其减速器是Redux工作原理的一部分，但它不是Redux。useReducer函数与它的减速器紧密耦合，减速器也适用于它的分派函数。我们只将action对象分派给该减速器。而在Redux中，dispatch函数将action对象发送给存储，存储将其分发给所有组合的减速函数。您可以将Redux看作一个全局事件总线，它接受任何事件(操作)，并根据操作的有效负载和之前的状态将它们处理为一个新的状态。

没有useReducer中间件

Redux附带了一个丰富的中间件生态系统。Redux中中间件的一个简单示例是动作日志记录器:通过Redux的每个动作都将记录在浏览器的开发工具中。您可以看到在分派操作经过还原器前后状态的情况。这只是Redux中中间件的一个例子。有很多。

目前还没有useReducer的中间件。因为它不是一个全局的状态容器(请参阅前面的部分)，所以很难在全局应用这样的中间件，但是首先要将Redux的中间件1:1转换为useReducer也不容易。如果您正在使用useReducer + useContext作为Redux的替代品，那么您可能会错过React应用程序中丰富的中间件生态系统。

没有副作用的中间件

Redux中流行的副作用库有Redux Thunk和Redux Saga。它们不仅用于异步逻辑(例如数据获取)，还用于应用程序中状态转换的集中控制流。特别是Redux Saga可以用于在状态管理系统中设置复杂的控制流。它使用Redux打开了状态管理的另一个维度，这在日常的React应用程序中很少需要。

这两点是useReducer加上其他东西(例如useContext)成为完整的Redux实现所缺少的要点。也许我们能做到这一点，但反对它的最佳论据将是:我们为什么要重新发明轮子?无论如何，请在评论中让我知道useReducer + useContext如何为您组成一个有效的Redux替代方案。

我想有一些经验法则可以遵循:如果状态管理不需要所有的Redux特性，那么使用useState、useReducer和useContext。如果您的状态管理需要Redux作为一个带有中间件的全局状态容器，请将Redux引入您的应用程序，以处理复杂和大型应用程序中的状态逻辑。

将useState用于基本和简单/小型应用程序。

对高级/中型应用程序使用useState + useReducer + useContext。

对复杂/大型应用程序使用useState/useReducer + Redux。

当然有很多细微差别。例如，使用useState或useReducer有其自身的好处。在React应用程序中使用Redux也是如此。您可能会遇到这样的情况:中间件可以实现复杂的控制流或副作用，或者没有Redux开发工具或时间旅行调试就无法实现这些功能。每件事都是有代价的，但在React的生态系统中，每件事都有自己的位置。